#!/bin/bash
#----------------------------------------------------------------------------------------------------------------------------------------------------------
# Description: This script finds and removes orphaned snap packages (not default providers or bases) and disabled snaps.
# Adds undo functionality to list and reinstall snaps removed in the last run.
# License: MIT. Copyright (c) 2024 Mario Herrmann.
#----------------------------------------------------------------------------------------------------------------------------------------------------------

set -euo pipefail

SCRIPT_NAME="orphand_snaps"
INSTALL_PATH="/usr/local/bin/${SCRIPT_NAME}"
SERVICE_NAME="orphand-snaps.service"
TIMER_NAME="orphand-snaps.timer"
SYSTEMD_DIR="/etc/systemd/system"

# State file to record last removed snaps
STATE_DIR="/var/lib/${SCRIPT_NAME}"
STATE_FILE="${STATE_DIR}/last_removed.txt"

# Pick sudo or doas. Override with OVERRIDE_ELEVATION=sudo|doas
choose_elev() {
  if [ "${OVERRIDE_ELEVATION:-}" = "sudo" ]; then
    echo "sudo"; return
  elif [ "${OVERRIDE_ELEVATION:-}" = "doas" ]; then
    echo "doas"; return
  fi
  if command -v doas >/dev/null 2>&1; then
    echo "doas"
  elif command -v sudo >/dev/null 2>&1; then
    echo "sudo"
  else
    echo "Error: Neither sudo nor doas found in PATH." >&2
    exit 1
  fi
}

ELEV_BIN="$(choose_elev)"

install_units() {
  echo "Installing ${SCRIPT_NAME} to ${INSTALL_PATH}..."
  "$ELEV_BIN" install -m 0755 "$0" "$INSTALL_PATH"

  echo "Preparing state directory..."
  "$ELEV_BIN" install -d -m 0755 "${STATE_DIR}"
  "$ELEV_BIN" touch "${STATE_FILE}"

  echo "Creating systemd service and timer..."
  "$ELEV_BIN" tee "${SYSTEMD_DIR}/${SERVICE_NAME}" >/dev/null <<'SERVICE'
[Unit]
Description=Remove orphaned and disabled snaps

[Service]
Type=oneshot
ExecStart=/usr/local/bin/orphand_snaps
Nice=10
IOSchedulingClass=best-effort
IOSchedulingPriority=7

[Install]
WantedBy=multi-user.target
SERVICE

  "$ELEV_BIN" tee "${SYSTEMD_DIR}/${TIMER_NAME}" >/dev/null <<'TIMER'
[Unit]
Description=Weekly cleanup of orphaned and disabled snaps

[Timer]
OnCalendar=weekly
Persistent=true
AccuracySec=1h
Unit=orphand-snaps.service

[Install]
WantedBy=timers.target
TIMER

  echo "Reloading systemd and enabling timer..."
  "$ELEV_BIN" systemctl daemon-reload
  "$ELEV_BIN" systemctl enable --now "${TIMER_NAME}"

  echo "Installation complete. The timer is active:"
  systemctl list-timers "${TIMER_NAME}" --no-legend || true
}

uninstall_units() {
  echo "Disabling and removing systemd timer and service..."
  "$ELEV_BIN" systemctl disable --now "${TIMER_NAME}" || true
  "$ELEV_BIN" systemctl disable "${SERVICE_NAME}" 2>/dev/null || true
  "$ELEV_BIN" systemctl daemon-reload

  "$ELEV_BIN" rm -f "${SYSTEMD_DIR}/${TIMER_NAME}" "${SYSTEMD_DIR}/${SERVICE_NAME}"

  echo "Removing ${INSTALL_PATH}..."
  "$ELEV_BIN" rm -f "${INSTALL_PATH}"

  echo "Removing state directory..."
  "$ELEV_BIN" rm -rf "${STATE_DIR}"

  echo "Uninstallation complete."
}

# State file format (from now on):
# Line 1: "# timestamp: <ISO8601>"
# Following lines: "<name>[,<channel>][,<revision>]"

# helper: get channel of a snap from 'snap info'
get_snap_channel() {
  # best-effort: pick the currently tracking channel if installed, else default stable
  local name="$1"
  # Try reading tracking channel from 'snap list'
  local ch
  ch=$(snap list 2>/dev/null | awk -v n="$name" '$1==n {print $NF}' | sed 's/^-$/stable/')
  if [ -n "$ch" ]; then
    echo "$ch"; return
  fi
  # Fallback: use stable
  echo "stable"
}

# Record removed snaps to the state file (one name per line, de-duplicated)
record_removed() {
  local removed_list=("$@")
  "$ELEV_BIN" install -d -m 0755 "${STATE_DIR}"
  {
    echo "# timestamp: $(date -Iseconds)"
    printf "%s\n" "${removed_list[@]}" | awk 'NF' | sort -u
  } | "$ELEV_BIN" tee "${STATE_FILE}" >/dev/null
}

# Undo helpers
undo_list() {
  if ! "$ELEV_BIN" test -f "${STATE_FILE}"; then
    echo "No undo information available."; return 0
  fi
  echo "Snaps removed in last run (name,channel[,revision]):"
  "$ELEV_BIN" awk 'NR>1 {print $0}' "${STATE_FILE}"
}

undo_install_one() {
  local snapname="${1:-}"
  if [ -z "${snapname}" ]; then
    echo "Usage: ${SCRIPT_NAME} undo snapname"; return 1
  fi
  if ! "$ELEV_BIN" awk -F, -v s="$snapname" 'NR>1 && $1==s {found=1} END{exit !found}' "${STATE_FILE}" 2>/dev/null; then
    echo "Snap '${snapname}' not found in last removal list."; return 1
  fi
  # Extract channel (and ignore revision; store may not offer specific rev)
  channel=$("$ELEV_BIN" awk -F, -v s="$snapname" 'NR>1 && $1==s {print $2; exit}' "${STATE_FILE}")
  if [ -n "${channel}" ]; then
    echo "Reinstalling '${snapname}' on channel '${channel}'..."
    "$ELEV_BIN" snap install --channel "${channel}" "${snapname}"
  else
    echo "Reinstalling '${snapname}'..."
    "$ELEV_BIN" snap install "${snapname}"
  fi
}

undo_install_all() {
  if ! "$ELEV_BIN" test -f "${STATE_FILE}"; then
    echo "No undo information available."; return 0
  fi
  echo "Reinstalling all snaps from last run..."
  "$ELEV_BIN" awk -F, 'NR>1 {print $1 "|" $2}' "${STATE_FILE}" | while IFS='|' read -r name channel; do
    [ -n "$name" ] || continue
    if [ -n "$channel" ]; then
      echo "Reinstalling '${name}' on channel '${channel}'..."
      "$ELEV_BIN" snap install --channel "$channel" "$name" || echo "Failed to reinstall '${name}'."
    else
      echo "Reinstalling '${name}'..."
      "$ELEV_BIN" snap install "$name" || echo "Failed to reinstall '${name}'."
    fi
  done
}

run_cleanup() {
  local removed=()

  # Remove disabled snaps (we know the exact revision being removed)
  LANG=C snap list --all | awk "/disabled/{print \$1, \$3}" |
    while read -r snapname revision; do
      # capture channel (best-effort)
      channel=$(get_snap_channel "$snapname")
      if "$ELEV_BIN" snap remove "$snapname" --revision="$revision"; then
        removed+=("${snapname},${channel},${revision}")
      else
        echo "Error removing disabled snap ${snapname}@${revision}"
      fi
    done

  # Orphans (current active revision removed; store channel)
  orphan=$(snap connections --all | grep -E 'content' | grep -vE 'themes|slot' | awk '$2 == "-" {print $3}' | cut -d: -f 1)
  provider=$(grep "default-provider:" /snap/*/*/meta/snap.yaml 2>/dev/null | awk '{print $NF}' | sort -u)
  if [ -n "${orphan}" ]; then
    for o in ${orphan}; do
      plug=$(snap connections "$o" | grep -E 'content' | awk '$2!= "-" {print $2}' | cut -d: -f 1 | sort -u)
      if [[ " ${provider} " =~ " ${o} " ]]; then
        echo "Snap ${o} is a default provider for ${plug} and cannot be removed."
      else
        channel=$(get_snap_channel "$o")
        if "$ELEV_BIN" snap remove "${o}"; then
          removed+=("${o},${channel}")
        else
          echo "Error removing snap ${o}"
        fi
      fi
    done
  else
    echo "No orphaned snaps found."
  fi

  # Bases
  corephan=$(snap list --all | grep -E 'base' | awk '{print $1}' | cut -d: -f 1)
  base=$(grep "base:" /snap/*/*/meta/snap.yaml 2>/dev/null | awk '{print $NF}' | sort -u)
  for b in ${corephan}; do
    bplug=$(grep "base:" /snap/*/*/meta/snap.yaml 2>/dev/null | cut -d '/' -f 3 | awk '{print $NF}' | sort -u)
    if [[ " ${base} " =~ " ${b} " ]]; then
      echo "${b} is a base for ${bplug} and cannot be removed."
    else
      channel=$(get_snap_channel "$b")
      if "$ELEV_BIN" snap remove "${b}"; then
        removed+=("${b},${channel}")
      else
        echo "Error removing snap ${b}"
      fi
    fi
  done

  if [ "${#removed[@]}" -gt 0 ]; then
    record_removed "${removed[@]}"
    echo "Recorded ${#removed[@]} removed snap(s) for undo."
  else
    "$ELEV_BIN" install -d -m 0755 "${STATE_DIR}"
    echo "# timestamp: $(date -Iseconds)" | "$ELEV_BIN" tee "${STATE_FILE}" >/dev/null
    echo "No snaps removed; undo list cleared."
  fi
}

case "${1:-}" in
  install)
    install_units
    ;;
  uninstall|remove)
    uninstall_units
    ;;
  undo)
    # undo [snapname|all|<none>]
    case "${2:-}" in
      "" )
        undo_list
        ;;
      all)
        undo_install_all
        ;;
      *)
        undo_install_one "${2}"
        ;;
    esac
    ;;
  *)
    run_cleanup
    ;;
esac
